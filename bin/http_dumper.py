#!/usr/bin/env python3

import argparse
from datetime import datetime
from dns import (
    resolver,
    reversename,
)
import ipaddress
import subprocess
import socket
import ssl

from OpenSSL import crypto
import requests


ssl_ctx = ssl.create_default_context()
ssl_ctx.check_hostname = False
ssl_ctx.verify_mode = ssl.CERT_NONE


def build_url(host, port, proto):
    return f'{proto}://{host}:{port}/'


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='HTTP screen grabber and response dumper.')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('-r', '--range', help='CIDR notation, e.g. "10.0.0.0/24"')
    group.add_argument('-l', '--hosts', help='IP list in a text file')
    parser.add_argument('-x', '--executable', default='chromium', help='E.g. "chrome"')
    parser.add_argument('-t', '--timeout', help='In seconds')
    parser.add_argument('-d', '--dns', default='8.8.8.8')
    parser.add_argument('-p', '--port', dest='ports', nargs='+', help='E.g. "-p 80/http 443/https 8000/http 8443/https"')
    args = parser.parse_args()

    if args.range:
        ips = [str(ip) for ip in ipaddress.ip_network(args.range).hosts()]
    elif args.hosts:
        with open(args.hosts) as fil:
            ips = [line.rstrip() for line in fil]
    else:
        raise Exception('Provide --range or --hosts argument')
    ports = [arg_port.split('/') for arg_port in args.ports]

    todos = dict(((ip, port[0], port[1]), list()) for ip in ips for port in ports)

    for ip in ips:

        # If HTTPS extract certificate details and add all extra host names to the list
        for port, proto in ports:
            if proto == 'https':
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(2)
                    sock.connect((ip, int(port)))
                except (TimeoutError, socket.timeout):
                    print(f'{ip}:{port} timed out...')
                    del(todos[(ip, port, proto)])
                else:
                    with ssl_ctx.wrap_socket(sock, server_hostname=ip) as ssock:
                        cert = ssock.getpeercert(True)
                        x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, cert)
                        for i in range(0, x509.get_extension_count()):
                            ext = x509.get_extension(i)
                            if 'subjectAltName' in str(ext.get_short_name()):
                                for alt in [alt.split(':')[1] for alt in str(ext).split(',')]:
                                    if not alt.startswith('*'):
                                        try:
                                            int(alt)
                                        except ValueError:
                                            # That's right, append on exception
                                            todos[(ip, port, proto)].append(alt)
                                        else:
                                            pass
    final_todos = list()

    for base, alts in todos.items():

        # Add the host and port combination
        final_todos.append(build_url(*base))

        # Add URL based on resolved name for that IP address
        res = resolver.Resolver()
        res.nameservers = [args.dns]
        try:
            response = res.query(reversename.from_address(ip), 'PTR')
        except resolver.NXDOMAIN:
            pass
        else:
            final_todos.append(build_url(response.rrset.items[0].to_text(), base[1], base[2]))

        # Now all the alternative names
        for alt in alts:
            final_todos.append(build_url(alt, base[1], base[2]))

    now = datetime.now()

    print(f'Using DNS: {args.dns}')

    for url in final_todos:

        # Grab the screen
        base_filename = url.replace('://', '_').replace(':', '-')[:-1] + '-' + now.strftime('%Y%m%d_%H%M')
        subprocess.call([args.executable, '--headless', '--disable-gpu', '--window-size=1280,1696', f'--screenshot={base_filename}.png', url])

        # Now the raw response
        try:
            response = requests.get(url, verify=False)
        except requests.exceptions.ConnectionError:
            pass
        else:
            with open(f'{base_filename}.txt', 'w') as fil:
                fil.write('\n'.join([header + ': ' + value for header, value in response.headers.items()]))
                fil.write('\n\n')
                fil.write(response.content.decode('utf8'))

        print(f'Processed {url}')
